// ========== GENERATOR & DATASOURCE ==========
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["views", "fullTextSearch", "postgresqlExtensions", "relationJoins"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [pg_trgm, unaccent, pg_partman, timescaledb]
}

// ========== MODELO USUARIO OPTIMIZADO ==========
model User {
  id                String     @id @default(uuid())
  email             String     @unique
  name              String?
  avatar            String?
  timezone          String     @default("UTC")
  lastActiveAt      DateTime?
  totalTasksCount   Int        @default(0)
  completedTasksCount Int      @default(0)
  currentStreakDays Int        @default(0)
  preferences          UserPreferences?
  tasks                UserTaskAssignment[]
  taskSessions         TaskSession[]
  recommendations      Recommendation[]
  dailyJournals        DailyJournal[]
  quickNotes           QuickNote[]
  studyPlans           StudyPlan[]
  workContext          WorkContext?
  userStats            UserStats?
  achievements         Achievement[]
  notifications        Notification[]
  dailyStats           UserDailyStats[]
  deletedAt DateTime?
  isDeleted Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?
  @@index([email])
  @@index([isDeleted, createdAt])
  @@index([lastActiveAt])
  @@index([totalTasksCount, completedTasksCount])
  @@index([isDeleted])
}

model UserPreferences {
  id                    String @id @default(uuid())
  userId                String @unique
  defaultTimeTechnique  TimeTechnique @default(pomodoro)
  workingHoursStart     Int    @default(9)
  workingHoursEnd       Int    @default(17)
  pomodoroLength        Int    @default(25)
  shortBreakLength      Int    @default(5)
  longBreakLength       Int    @default(15)
  notificationsEnabled  Boolean @default(true)
  theme                 String  @default("light")
  language              String  @default("en")
  metricsCalculationFrequency MetricFrequency @default(daily)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ========== MODELOS CORE OPTIMIZADOS ==========
model Category {
  id          String  @id @default(uuid())
  name        String  @unique
  description String?
  color       String?
  icon        String?
  parentId    String?
  taskCount   Int     @default(0)
  path        String?
  level       Int     @default(0)
  parent   Category? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[] @relation("CategoryHierarchy")
  topics   Topic[]
  deletedAt DateTime?
  isDeleted Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?
  @@index([parentId])
  @@index([isDeleted, name])
  @@index([path])
  @@index([level, taskCount])
  @@index([isDeleted])
}

model Topic {
  id          String      @id @default(uuid())
  name        String
  description String?
  category    Category    @relation(fields: [categoryId], references: [id])
  categoryId  String
  difficulty  Difficulty  @default(medium)
  taskCount   Int         @default(0)
  avgCompletionTime Int?
  tasks        Task[]
  studyPlans   StudyPlanTopic[]
  topicNotes   TopicNote[]
  deletedAt DateTime?
  isDeleted Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?
  @@index([categoryId, isDeleted])
  @@index([difficulty])
  @@index([taskCount, avgCompletionTime])
  @@unique([name, categoryId])
  @@index([isDeleted])
}

model Task {
  id                String     @id @default(uuid())
  name              String
  description       String?
  topic             Topic      @relation(fields: [topicId], references: [id])
  topicId           String
  estimatedMinutes  Int?
  timeTechnique     TimeTechnique
  type              TaskType
  priority          Priority   @default(medium)
  status            TaskStatus @default(todo)
  plannedDate       DateTime?
  completedAt       DateTime?
  dueDate           DateTime?
  isSuggested       Boolean    @default(false)
  tags              String[]
  assigneeCount     Int        @default(0)
  sessionCount      Int        @default(0)
  totalMinutesSpent Int        @default(0)
  searchVector      Unsupported("tsvector")?
  sessions           TaskSession[]
  recommendations    Recommendation[]
  taskNotes          TaskNote[]
  quizzes            Quiz[]
  learningTechniques TaskLearningTechnique[]
  assignedUsers      UserTaskAssignment[]
  dependencies       TaskDependency[] @relation("DependentTask")
  dependents         TaskDependency[] @relation("PrerequisiteTask")
  deletedAt DateTime?
  isDeleted Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?
  @@index([topicId, isDeleted])
  @@index([priority, status])
  @@index([status, plannedDate], where: { isDeleted: false })
  @@index([dueDate, status], where: { isDeleted: false })
  @@index([searchVector], type: Gin)
  @@index([tags], type: Gin)
  @@index([topicId, status, priority])
  @@index([isSuggested, status, createdAt])
  @@index([assigneeCount, sessionCount])
  @@index([isDeleted])
}

model TaskDependency {
  id             String @id @default(uuid())
  prerequisiteTask Task  @relation("PrerequisiteTask", fields: [prerequisiteId], references: [id])
  prerequisiteId String
  dependentTask  Task   @relation("DependentTask", fields: [dependentId], references: [id])
  dependentId    String
  dependencyType DependencyType @default(finish_to_start)
  @@unique([prerequisiteId, dependentId])
  @@index([prerequisiteId])
  @@index([dependentId])
}

// ========== MODELO DE SESIONES PARTICIONADO ==========
model TaskSession {
  id                String     @id @default(uuid())
  task              Task       @relation(fields: [taskId], references: [id])
  taskId            String
  user              User       @relation(fields: [userId], references: [id])
  userId            String
  startTime         DateTime
  endTime           DateTime?
  plannedMinutes    Int?
  notes             String?
  interruptionLevel InterruptionLevel @default(none)
  productivityScore Int?       @db.SmallInt
  mood              Mood?
  energy            EnergyLevel?
  isBreak           Boolean @default(false)
  breakType         BreakType?
  durationMinutes   Int?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?
  partitionKey DateTime @default(now())
  @@index([taskId, startTime])
  @@index([userId, startTime])
  @@index([userId, endTime])
  @@index([startTime, endTime])
  @@index([productivityScore])
  @@index([partitionKey, userId])
  @@map("task_sessions")
}

// ========== NUEVO: CACHE DE MÉTRICAS DIARIAS ==========
model UserDailyStats {
  id                String   @id @default(uuid())
  userId            String
  date              DateTime @db.Date
  tasksPlanned      Int      @default(0)
  tasksCompleted    Int      @default(0)
  tasksInProgress   Int      @default(0)
  minutesWorked     Int      @default(0)
  sessionsCount     Int      @default(0)
  avgProductivity   Float?   @db.Real
  mostUsedTechnique TimeTechnique?
  avgMood           Float?   @db.Real
  avgEnergy         Float?   @db.Real
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?
  @@unique([userId, date])
  @@index([date])
  @@index([userId, date(sort: Desc)])
  @@index([tasksCompleted, minutesWorked])
}

// ========== SISTEMA DE NOTAS OPTIMIZADO ==========
model Note {
  id          String @id @default(uuid())
  content     String
  type        NoteType
  tags        String[]
  isPinned    Boolean @default(false)
  userId      String?
  taskId      String?
  topicId     String?
  user        User?  @relation(fields: [userId], references: [id])
  task        Task?  @relation(fields: [taskId], references: [id])
  topic       Topic? @relation(fields: [topicId], references: [id])
  deletedAt DateTime?
  isDeleted Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?
  @@index([userId, type, createdAt])
  @@index([taskId, type])
  @@index([topicId, type])
  @@index([tags], type: Gin)
  @@index([isPinned, createdAt])
  @@index([isDeleted])
}

// ========== SISTEMA DE RECOMENDACIONES OPTIMIZADO ==========
model RecommendationRule {
  id          String @id @default(uuid())
  name        String
  type        RecommendationType
  conditions  Json   // Condiciones dinámicas
  actions     Json   // Acciones a ejecutar
  priority    Int    @default(1)
  isActive    Boolean @default(true)
  @@index([type, priority])
  @@index([isActive])
}

model Recommendation extends Auditable {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  task        Task     @relation(fields: [taskId], references: [id])
  taskId      String
  ruleId      String?  // Referencia a la regla que generó la recomendación
  type        RecommendationType
  title       String
  description String
  confidence  Float    @db.Real
  isAccepted  Boolean?
  acceptedAt  DateTime?
  expiresAt   DateTime?
  @@index([userId, createdAt])
  @@index([taskId])
  @@index([type, confidence])
  @@index([expiresAt]) // Para limpieza automática
}

// ========== QUIZZES OPTIMIZADOS ==========
model Quiz extends SoftDeletable, Auditable {
  id          String   @id @default(uuid())
  task        Task     @relation(fields: [taskId], references: [id])
  taskId      String
  title       String
  description String?
  generatedBy String
  questionCount Int     @default(0)
  attemptCount  Int     @default(0)
  avgScore      Float?  @db.Real
  questions   QuizQuestion[]
  attempts    QuizAttempt[]
  @@index([taskId])
  @@index([avgScore, attemptCount]) // Para estadísticas
}

model QuizQuestion {
  id            String @id @default(uuid())
  quiz          Quiz   @relation(fields: [quizId], references: [id], onDelete: Cascade)
  quizId        String
  question      String
  type          QuestionType
  correctAnswer String
  options       String[]
  explanation   String?
  order         Int
  correctAnswers Int @default(0)
  totalAnswers   Int @default(0)
  answers QuizAnswer[]
  @@index([quizId, order])
  @@index([correctAnswers, totalAnswers]) // Para análisis de dificultad
}

model QuizAttempt extends Auditable {
  id        String @id @default(uuid())
  quiz      Quiz   @relation(fields: [quizId], references: [id])
  quizId    String
  userId    String
  score     Float  @db.Real
  maxScore  Float  @db.Real
  duration  Int?
  answers   QuizAnswer[]
  @@index([quizId, userId])
  @@index([userId, createdAt])
  @@index([score, duration]) // Para análisis de rendimiento
}

model QuizAnswer {
  id          String @id @default(uuid())
  attempt     QuizAttempt  @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  attemptId   String
  question    QuizQuestion @relation(fields: [questionId], references: [id])
  questionId  String
  answer      String
  isCorrect   Boolean
  timeSpent   Int?
  @@unique([attemptId, questionId])
  @@index([isCorrect, timeSpent]) // Para análisis
}

// ========== ASIGNACIONES SIMPLIFICADAS ==========
model UserTaskAssignment extends Auditable {
  id          String     @id @default(uuid())
  task        Task       @relation(fields: [taskId], references: [id])
  taskId      String
  user        User       @relation(fields: [userId], references: [id])
  userId      String
  assignedBy  String?
  role        AssignmentRole @default(assignee)
  progress    Int        @default(0) @db.SmallInt
  completedAt DateTime?
  estimatedHours Float?   @db.Real
  @@unique([taskId, userId])
  @@index([userId, completedAt])
  @@index([taskId, role])
  @@index([progress, completedAt]) // Para métricas
}

model TaskLearningTechnique {
  id          String @id @default(uuid())
  task        Task   @relation(fields: [taskId], references: [id])
  taskId      String
  technique   LearningTechnique
  effectiveness Float? @db.Real
  @@unique([taskId, technique])
  @@index([technique, effectiveness])
}

// ========== PLANES DE ESTUDIO OPTIMIZADOS ==========
model StudyPlan extends SoftDeletable, Auditable {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  name        String
  description String?
  startDate   DateTime
  endDate     DateTime
  goal        String
  status      StudyPlanStatus @default(draft)
  totalTopics     Int   @default(0)
  completedTopics Int   @default(0)
  totalHours      Float @default(0) @db.Real
  completedHours  Float @default(0) @db.Real
  focusTopics StudyPlanTopic[]
  milestones  StudyPlanMilestone[]
  @@index([userId, status])
  @@index([startDate, endDate])
  @@index([totalTopics, completedTopics]) // Para progreso
}

model StudyPlanTopic {
  id          String    @id @default(uuid())
  studyPlan   StudyPlan @relation(fields: [studyPlanId], references: [id], onDelete: Cascade)
  studyPlanId String
  topic       Topic     @relation(fields: [topicId], references: [id])
  topicId     String
  priority    Int       @default(1)
  estimatedHours Float  @db.Real
  actualHours    Float? @db.Real
  @@unique([studyPlanId, topicId])
  @@index([studyPlanId, priority])
  @@index([estimatedHours, actualHours]) // Para análisis
}

model StudyPlanMilestone extends Auditable {
  id            String    @id @default(uuid())
  studyPlan     StudyPlan @relation(fields: [studyPlanId], references: [id], onDelete: Cascade)
  studyPlanId   String
  title         String
  description   String?
  targetDate    DateTime
  completedAt   DateTime?
  isCompleted   Boolean   @default(false)
  @@index([studyPlanId, targetDate])
  @@index([targetDate, isCompleted]) // Para deadlines
}

// ========== CONTEXTO DE TRABAJO OPTIMIZADO ==========
model WorkContext extends Auditable {
  id           String      @id @default(uuid())
  user         User        @relation(fields: [userId], references: [id])
  userId       String      @unique
  role         String
  currentFocus String?
  energyLevel  EnergyLevel @default(medium)
  environment  WorkEnvironment @default(office)
  availability AvailabilityStatus @default(available)
  activeUntil  DateTime?
  @@index([availability])
  @@index([activeUntil])
}

// ========== MÉTRICAS BATCH OPTIMIZADAS ==========
model MetricsBatch extends Auditable {
  id            String      @id @default(uuid())
  batchId       String      @unique
  type          BatchType
  status        BatchStatus @default(pending)
  startTime     DateTime?
  endTime       DateTime?
  processedRecords Int      @default(0)
  errorCount    Int         @default(0)
  errorDetails  Json?
  @@index([type, status])
  @@index([startTime, endTime])
  @@index([status, createdAt])
}

model MetricCache {
  id          String @id @default(uuid())
  userId      String
  metricType  String
  period      String
  periodStart DateTime
  periodEnd   DateTime
  value       Json
  computedAt  DateTime @default(now())
  expiresAt   DateTime
  @@unique([userId, metricType, period, periodStart])
  @@index([expiresAt]) // Para limpieza automática
  @@index([userId, metricType, period])
}

// ========== ESTADÍSTICAS SIMPLIFICADAS ==========
model UserStats extends Auditable {
  id                      String   @id @default(uuid())
  user                    User     @relation(fields: [userId], references: [id])
  userId                  String   @unique
  currentStreak           Int      @default(0)
  longestStreak           Int      @default(0)
  level                   Int      @default(1)
  experience              Int      @default(0)
  totalMinutesSpent       Int      @default(0)
  totalTasksCompleted     Int      @default(0)
  averageProductivity     Float    @db.Real @default(0)
  lastCalculatedAt        DateTime @default(now())
  @@index([level, experience])
  @@index([totalTasksCompleted, totalMinutesSpent])
}

// ========== JOURNAL OPTIMIZADO ==========
model DailyJournal extends Auditable {
  id         String   @id @default(uuid())
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  date       DateTime @db.Date
  highlights String?
  challenges String?
  mood       Mood
  energy     EnergyLevel
  nextSteps  String?
  gratitude  String?
  learnings  String?
  rating     Int?     @db.SmallInt
  @@unique([userId, date])
  @@index([userId, date(sort: Desc)])
  @@index([mood, energy, rating]) // Para análisis de bienestar
}

// ========== GAMIFICACIÓN OPTIMIZADA ==========
model Achievement extends Auditable {
  id          String @id @default(uuid())
  user        User   @relation(fields: [userId], references: [id])
  userId      String
  type        AchievementType
  title       String
  description String
  points      Int
  rarity      AchievementRarity @default(common)
  metadata    Json? // Datos específicos del logro
  @@index([userId, type])
  @@index([type, rarity])
  @@index([points, rarity]) // Para rankings
}

// ========== NOTIFICACIONES PARTICIONADAS ==========
model Notification extends Auditable, TimePartitioned {
  id        String @id @default(uuid())
  user      User   @relation(fields: [userId], references: [id])
  userId    String
  type      NotificationType
  title     String
  message   String
  isRead    Boolean @default(false)
  readAt    DateTime?
  priority  NotificationPriority @default(normal)
  metadata  Json?
  expiresAt DateTime?
  @@index([userId, isRead, createdAt])
  @@index([type, priority])
  @@index([expiresAt]) // Para limpieza automática
  @@index([partitionKey, userId]) // Para particionado
  @@map("notifications")
}

// ========== AUDITORÍA PARTICIONADA ==========
model AuditEvent extends TimePartitioned {
  id         String   @id @default(uuid())
  entityType String
  entityId   String
  action     AuditAction
  userId     String?
  changes    Json
  metadata   Json?
  timestamp  DateTime @default(now())
  ipAddress  String?
  userAgent  String?
  @@index([entityType, entityId])
  @@index([userId, timestamp])
  @@index([action, timestamp])
  @@index([partitionKey, entityType]) // Para particionado
  @@map("audit_events")
}

// ========== ENUMS ACTUALIZADOS ==========
enum TimeTechnique {
  pomodoro
  deep_work
  time_block
  eisenhower
  getting_things_done
  flowtime
  ultradian
  custom
}

enum TaskType {
  input
  output
  mixed
  maintenance
  creative
  analytical
}

enum Priority {
  urgent_important
  urgent_not_important
  not_urgent_important
  not_urgent_not_important
  low
  medium
  high
  critical
}

enum TaskStatus {
  todo
  in_progress
  blocked
  review
  done
  cancelled
}

enum InterruptionLevel {
  none
  minimal
  low
  medium
  high
  severe
}

enum FatigueLevel {
  fresh
  low
  medium
  high
  exhausted
}

enum Mood {
  excellent
  good
  neutral
  low
  poor
}

enum EnergyLevel {
  very_low
  low
  medium
  high
  very_high
}

enum Difficulty {
  beginner
  easy
  medium
  hard
  expert
}

enum NoteType {
  QUICK
  TASK
  TOPIC
  MEETING
  IDEA
  RESOURCE
  SOLUTION
  OBSTACLE
  INSIGHT
}

enum DependencyType {
  finish_to_start
  start_to_start
  finish_to_finish
  start_to_finish
}

enum BreakType {
  short
  long
  meal
  exercise
  walk
  social
}

enum RecommendationType {
  task_suggestion
  break_reminder
  technique_suggestion
  schedule_optimization
  productivity_tip
  learning_path
}

enum QuestionType {
  multiple_choice
  true_false
  short_answer
  essay
  matching
}

enum AssignmentRole {
  assignee
  reviewer
  collaborator
  observer
}

enum LearningTechnique {
  spaced_repetition
  active_recall
  feynman_technique
  mind_mapping
  note_taking
  summarization
  practice_testing
}

enum StudyPlanStatus {
  draft
  active
  paused
  completed
  cancelled
}

enum WorkEnvironment {
  home
  office
  coworking
  library
  cafe
  remote
  hybrid
}

enum AvailabilityStatus {
  available
  busy
  focused
  break
  meeting
  offline
}

enum AchievementType {
  streak
  productivity
  consistency
  learning
  milestone
  social
  efficiency
}

enum AchievementRarity {
  common
  uncommon
  rare
  epic
  legendary
}

enum NotificationType {
  task_reminder
  break_reminder
  deadline_alert
  achievement_unlock
  recommendation
  system_update
  social_activity
}

enum NotificationPriority {
  low
  normal
  high
  urgent
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  RESTORE
  ARCHIVE
  LOGIN
  LOGOUT
}

// ========== NUEVOS ENUMS ==========
enum MetricFrequency {
  realtime
  hourly
  daily
  weekly
}

enum BatchType {
  daily_metrics
  weekly_metrics
  monthly_metrics
  user_stats
  recommendations
  cleanup
}

enum BatchStatus {
  pending
  running
  completed
  failed
  cancelled
}